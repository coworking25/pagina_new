-- Tabla de Auditoría General del Sistema
-- Req 50: Visualizador de Logs de Auditoría

CREATE TABLE IF NOT EXISTS audit_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  table_name TEXT NOT NULL,
  record_id TEXT NOT NULL,
  action TEXT NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE')),
  old_data JSONB,
  new_data JSONB,
  changed_by UUID REFERENCES auth.users(id),
  user_email TEXT, -- Para facilitar la lectura sin joins complejos
  changed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para búsqueda rápida
CREATE INDEX IF NOT EXISTS idx_audit_logs_table_name ON audit_logs(table_name);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_changed_at ON audit_logs(changed_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_logs_record_id ON audit_logs(record_id);

-- Habilitar RLS
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- Políticas de seguridad
-- Solo administradores pueden ver los logs
CREATE POLICY "Admins can view audit logs" ON audit_logs
  FOR SELECT
  USING (
    auth.uid() IN (
      SELECT id FROM auth.users WHERE raw_user_meta_data->>'role' = 'admin'
      UNION
      SELECT id FROM public.advisors WHERE email = (SELECT email FROM auth.users WHERE id = auth.uid())
    )
  );

-- Función genérica para trigger de auditoría
CREATE OR REPLACE FUNCTION log_audit_event()
RETURNS TRIGGER AS $$
DECLARE
  v_old_data JSONB;
  v_new_data JSONB;
  v_user_id UUID;
  v_user_email TEXT;
BEGIN
  -- Obtener usuario actual
  v_user_id := auth.uid();
  
  -- Intentar obtener email del usuario (opcional)
  BEGIN
    SELECT email INTO v_user_email FROM auth.users WHERE id = v_user_id;
  EXCEPTION WHEN OTHERS THEN
    v_user_email := 'system';
  END;

  IF (TG_OP = 'INSERT') THEN
    v_new_data := to_jsonb(NEW);
    INSERT INTO audit_logs (table_name, record_id, action, new_data, changed_by, user_email)
    VALUES (TG_TABLE_NAME, NEW.id::TEXT, 'INSERT', v_new_data, v_user_id, v_user_email);
    RETURN NEW;
  ELSIF (TG_OP = 'UPDATE') THEN
    v_old_data := to_jsonb(OLD);
    v_new_data := to_jsonb(NEW);
    INSERT INTO audit_logs (table_name, record_id, action, old_data, new_data, changed_by, user_email)
    VALUES (TG_TABLE_NAME, NEW.id::TEXT, 'UPDATE', v_old_data, v_new_data, v_user_id, v_user_email);
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    v_old_data := to_jsonb(OLD);
    INSERT INTO audit_logs (table_name, record_id, action, old_data, changed_by, user_email)
    VALUES (TG_TABLE_NAME, OLD.id::TEXT, 'DELETE', v_old_data, v_user_id, v_user_email);
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Ejemplos de cómo activar el trigger en tablas importantes (Descomentar para activar)

-- CREATE TRIGGER audit_properties_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON properties
-- FOR EACH ROW EXECUTE FUNCTION log_audit_event();

-- CREATE TRIGGER audit_appointments_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON appointments
-- FOR EACH ROW EXECUTE FUNCTION log_audit_event();

-- CREATE TRIGGER audit_clients_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON clients
-- FOR EACH ROW EXECUTE FUNCTION log_audit_event();
